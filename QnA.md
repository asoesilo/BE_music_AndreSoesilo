Describe in a high level the solution you have in mind
> For the recommendation engine, I collected the list of songs that the user's followees had listened to and gave each song with a relevance point. The points were calculated based on the genres of the song and the genres of songs that the user had listened to. If there were enough songs to recommended using the followees song list
>
> The recommended song list was sorted based on the relevance points, and the top five songs were returned.

What other data could you use to improve recommendations?
> Other data that could improve recommendations include:
* name of the song artists
* song release date
* number of times each song was played by the user
* number of times a song is played by everyone
* date/time a song was played by the user
>
> All of these data could be incorporated into the point system, so that more relevant song list can be returned.

Assume a more real world situation where you could have more data you described above, and more time to implement, could you think of a possibly more efficient way to recommend?
> All of the data mentioned above could then be used to improve the point system:
* songs from artists, which the user had listened to, receive more points
* newer songs get more points
* the more frequent a song is played indicates that user likes this song. Thus, songs from this song's genres and artist get more points.
* general song counts can be used to find the hottest songs being liked by everyone. Thus, these songs can also be recommended if it falls into the genres that the user likes to listen.
* date/time each song was played by the user indicates, which songs the user enjoy listening to now instead of in the past

Assume you have more than one implementation of recommendations, how could you test which one is more effective using data generated by user actions?
> I would use A/B testing to find which recommendations implementation is more effective. We deploy each recommendations implementations for the same length of time to the same set of users. Then, we keep track of the number of songs being recommended that are being clicked and played by the users.

--

How long did this assignment take?
> This assignment took 5 days to complete, in which two days was used to learn the MEN stack (MongoDB, ExpressJS, NodeJS), 0.5 days for DB and implementation design, and 2.5 days for development and testing.

Where would be the bottlenecks of this solution you have implemented?
> A few bottlenecks of my solution include:
* asynchronous music listening call for the same user will cause problems for the music recommendation calculation, because of the race conditions in keeping track of the genres that the user has listened to.
* more varieties in the genres that the user listens to can increase the size of the user entry in the DB, which may result in bigger space needed for the entry and causes expensive entry re-allocation. This is when we can track the genres listened by each users in its own collection.
* as the number of songs listened by the users' followees grows, there will be more songs that need to be processed. This will increase the amount of time needed to provide the recommendation song list. A solution for this can be to deploy the recommendation engine on a different server, so that it does not take up the server time for other requests.

What was the hardest part?
> Other than the implementation of the music recommendation algorithm, the hardest part was to get used to the asynchronous aspect of NodeJS. Since the frameworks that I used previously were mostly synchronous, I had to frequently re-think the way the app and tests were implemented.

Did you learn something new?
> Yes, definitely. I had fun learning the MEN stack. As I mentioned above, the asynchronous aspect of NodeJS was tricky, but it taught me how to efficiently implement my code to allow different part of independent codes run in parallel. Designing the MongoDB collections is also different from designing a relational database, because I had to think of how the collections will be queried, instead of just the relationships between tables to avoid information duplication.

Do you feel that your skills were well tested?
> Yes, it was a small assignment but it was fun and it tests the different aspects of my skills, which include learning abilities, problem solving, database design, code design and testing.